#include <stdio.h>
//백트래킹
//모든 경우의 수를 시도하면서, 조건을 만족하지 않는 경우
//다시 되돌아 가서 다는 경로를 시도하는 방식의 풀이

//해당 방식의 구현은 주로, 자기 자신을 다시 호출하는 재귀식 설계로 구현됨


//동작과정
//1.선택 : 가능한 수를 하나 선택함
//2.검증 : 선택된 수가 조건을 만족하는지 확인
//3.재귀 호출 : 조건을 만족했을 경우 다음 단계로 진행
//4.백트래킹 : 조건을 만족하지 않을 경우 선택을 취소하고 이전 단계로 돌아감

// == 구현 시작==
//1. 숫자 사용 여부에 대한 배열 작성
int used[9];
//2. 수열을 담을 배열 작성
int path[9];
//3. 함수 설계
// N : 범위
// M : 선택된 수의 개수
//depth : 현재까지 선택된 수의 개수
//path : 현재까지 선택된 수열을 담은 배열
void backtracking(int N, int M, int depth, int path[])
{
	//4. 조건) 현재까지 선택된 수가 M과 동일한 경우의 작업
	if (depth == M)
	{
		//설정된 결과 값 출력
		for (int i = 0; i < M; i++)
		{
			printf("%d ", path[i]);
		}
		printf("\n");
		return;
	}
	//5. 일반적인 경우 실행할 작업
	//현재 문제에서는 1부터 N까지의 범위를 사용중
	for (int i = 1; i <= N; i++)
	{
		//used[i] 가 사용되지 않은 상태라면(= 0)
		if (!used [i])
		{
			used[i] = 1; //조건으로 사용할 경우 1은 참, 0은 거짓임
			path[depth] = i; //현재의 1값을 작업순서(depth)에 있는 path에 등록 합니다.

			//7. 백트래킹 작업
			//depth의 값을 1 증가시키고 다시 함수를 호출함
			backtracking(N, M, depth + 1, path);



			//8. 위 작업이 마무리 되면 사용했던 used를 다시 0으로 만들어서 비사용 처리 진행
			used[i] = 0;
		}
	}

}




int main()
{
	int N, M;
	scanf_s("%d %d", &N, &M);

	backtracking(N, M, 0, path);
	//배열의 시작 값이 0이기 때문에 0을 넣음
	
	
	//해당 문제의 작업 순서
	//1. scanf 에 의해 N과 M이 결정됩니다.
	//2.backtracking(3,2,0,path) 호출이 진행됩니다.
	//3.내부에서 M과 depth(0)은 서

	//b(3,2,0,p)
	//i


	return 0;
}